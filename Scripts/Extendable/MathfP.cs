using UnityEngine;
using System.Collections;
using System.Collections.Generic;

namespace ExtensionMethods
{
    public static class MathfP
    {
        /// <summary>
        /// Returns the angle of the vector in radians. Through Cos method generated by the origin and the target.
        /// </summary>
        /// <param name="origin">The point in 2D space where the vector start.</param>
        /// <param name="target">The point in 2D space where the vector ends.</param>
        /// <returns><seealso cref="float"/> angle in radians.</returns>
        public static float AngleCosRadian(Vector2 origin, Vector2 target)
        {
            Vector2 distSide = target - origin;
            float h = distSide.magnitude;
            float cos = distSide.x / h;
            float result = cos >= 0 ? cos : -cos;
            return result;
        }


        /// <summary>
        /// Returns the angle of the vector in radians. Through Sin method generated by the origin and the target.
        /// </summary>
        /// <param name="origin">The point in 2D space where the vector start.</param>
        /// <param name="target">The point in 2D space where the vector ends.</param>
        /// <returns><seealso cref="float"/> angle in radians.</returns>
        public static float AngleSinRadian(Vector2 origin, Vector2 target)
        {
            Vector2 distSide = target - origin;
            float h = distSide.magnitude;
            float sin = distSide.y / h;
            return sin;
        }


        /// <summary>
        /// Generates a projectile motion between origin and target.
        /// </summary>
        /// <param name="origin">The point in 2D space where the projectile motion start.</param>
        /// <param name="target">The point in 2D space where the projectile motion ends.</param>
        /// <returns><seealso cref="Vector2"/> with the initial momentum.</returns>
        public static Vector2 ProjectileMotion(Vector2 origin, Vector2 target)
        {
            // As I said in the previous post. You can remove t from the formulas
            float Vx(float x) => x / AngleCosRadian(origin, target);
            float Vy(float y) => y / Mathf.Abs(AngleSinRadian(origin, target)) + .5f * Mathf.Abs(Physics2D.gravity.y);

            float hY = target.y - origin.y;
            float dX = target.x - origin.x;

            Vector2 v0 = new Vector2(dX, 0).normalized;
            v0 *= Vx(Mathf.Abs(dX));
            v0.y = Vy(hY);

            return v0;
        }

        // In this method you can add t in the parameters
        /// <summary>
        /// Generates a projectile motion between origin and target.
        /// </summary>
        /// <param name="origin">The point in 2D space where the projectile motion start.</param>
        /// <param name="target">The point in 2D space where the projectile motion ends.</param>
        /// <param name="t">The time of flight of a projectile motion.</param>
        /// <returns><seealso cref="Vector2"/> with the initial momentum.</returns>
        public static Vector2 ProjectileMotion(this Vector2 origin, Vector2 target, float t)
        {
            float Vx(float x) => x / AngleCosRadian(origin, target) * t;
            float Vy(float y) => y / (Mathf.Abs(AngleSinRadian(origin, target)) * t) + .5f * Mathf.Abs(Physics2D.gravity.y) * t;

            float hY = target.y - origin.y;
            float dX = target.x - origin.x;

            Vector2 v0 = new Vector2(dX, 0).normalized;
            v0 *= Vx(Mathf.Abs(dX));
            v0.y = Vy(hY);

            return v0;
        }

        /// <summary>
        ///  Calculates the angle to hit target
        /// </summary>
        /// <param name="distance">The distance from Source(Enemy) to Target(hero) e.g (Source-Target).magnitude</param>
        /// <param name="pvelocity">The projectiles velocity e.g (Speed)</param>
        /// <param name="angle">The angle that is been calculated</param>
        /// <returns>True if angle can be calculated or false if it cannot, the result is in angle</returns>
        public static bool AngleOfReach(float distance, float pvelocity, out float angle)
        {
            angle = 0.5F * (Mathf.Asin((-Physics.gravity.y * distance) / (pvelocity * pvelocity)) * Mathf.Rad2Deg);
            if (float.IsNaN(angle) == true)
            {
                angle = 0;
                return false;
            }

            return true;
        }

        // x = target.x, y = target.y
        // xtan(theta) - gx^2*sec^2(theta) / velocity^2*2
        // input x, y of target pos
        // returns angle
        //public static float CalculatePhysicsAngleTo(Vector2 origin, Vector2 target, float velocity) 
        //{
        //    float angle = target.x * Mathf.tan
        //}
        //public static bool GroundDetect(CapsuleCollider2D capsuleCollider2D, out RaycastHit2D raycastHit)
        //{
        //    float extraHeightText = .1f;
        //    raycastHit = Physics2D.BoxCast(capsuleCollider2D.bounds.center, capsuleCollider2D.bounds.size, 0f, Vector2.down, extraHeightText, LayerMask.GetMask("Ground"));
        //    //Debug.DrawRay(rb.position, Vector3.down, new Color(0, 1, 0));

            

        //    return raycastHit.collider != null;
        //}
        //public static void DrawRayCollider(CapsuleCollider2D capsuleCollider2D, Color defaultColor,Color onhitColor)
        //{
        //    Color rayColor;
        //    if (GroundDetect(capsuleCollider2D, out raycastHit))
        //    {
        //        rayColor = onhitColor;
        //    } else
        //    {
        //        rayColor = defaultColor;
        //    }
        //    Debug.DrawRay(capsuleCollider2D.bounds.center + new Vector3(capsuleCollider2D.bounds.extents.x, 0), Vector2.down * (capsuleCollider2D.bounds.extents.y + extraHeightText), rayColor);
        //    Debug.DrawRay(capsuleCollider2D.bounds.center - new Vector3(capsuleCollider2D.bounds.extents.x, 0), Vector2.down * (capsuleCollider2D.bounds.extents.y + extraHeightText), rayColor);
        //    Debug.DrawRay(capsuleCollider2D.bounds.center - new Vector3(capsuleCollider2D.bounds.extents.x, capsuleCollider2D.bounds.extents.y), Vector2.right * (capsuleCollider2D.bounds.extents.x), rayColor);
        //}
    }
}